/* TeamData.cfg
This script contains all team-related data and functionality,
using in score board, and team management
*/
import "StdLibrary.fcc" as StdLib
import "EditorGenLib.fcc" as EditorLib
import "Map.fcc" as Map
import "List.fcc" as List
import "../GlobalData/PlayerData.fcg" as PlayerData
import "../GlobalManager/GlobalGameManager.fcg" as GlobalGameManager
graph TeamData {
    teamWinningTimes Map<entity<Team>, int>  // Map to keep track of winning times for each team
    teamBooyah Map<entity<Team>, int>  // Map to keep track of booyah points for each team
    teamKills Map<entity<Team>, int>  // Map to keep track of kills for each team
    teamTotalPoints Map<entity<Team>, int>  // Map to keep track of total points for each team
    // On the game starts, init team points
    event OnAwake() {
        teamWinningTimes = Map<entity<Team>, int>{} // Initialize the team winning times map
        teamBooyah = Map<entity<Team>, int>{} // Initialize the team booyah points map
        teamKills = Map<entity<Team>, int>{} // Initialize the team kills map
        teamTotalPoints = Map<entity<Team>, int>{} // Initialize the team total points map
    }

    /* Initialize the team points map with zero points for each team.
       This function should be called at the start of the game.
    */
    func InitializeTeamPoints() {
        for index, team in GetAllTeams() {
            teamWinningTimes[team] = 0 // Set initial winning times to zero
            teamBooyah[team] = 0 // Set initial booyah points to zero
            teamKills[team] = 0 // Set initial kills to zero
            teamTotalPoints[team] = 0 // Set initial total points to zero
            // LogInfo("<TeamData.fcg>: Initialized points for team: " + team<Entity>.Name) // Debug Info
        }
    }

    /* Register a new team in the team points map.
       This function adds a new team to the map with an initial score of zero.
       @param team: The team entity to register
       (This function is called when a new team is added to the game)
       @return: Returns true if the operation was successful, false if the team was already registered
    */
    func RegisterTeamPoint(team entity<Team>) bool {
        if (!ContainKey(teamBooyah, team) && !ContainKey(teamKills, team) && !ContainKey(teamTotalPoints, team)) {
            teamWinningTimes[team] = 0 // Initialize winning times for the new team
            teamBooyah[team] = 0 // Initialize booyah points for the new team
            teamKills[team] = 0 // Initialize kills for the new team
            teamTotalPoints[team] = 0 // Initialize total points for the new team
            // LogError("<TeamData.fcg>: Registered new team: " + team) // Debug Info
            return true
        } else {
            LogWarning("<TeamData.fcg>: Team already registered: " + team) // Warning Info
            return false
        }
    }

    /* Add points to a specific team's score.
       @param team: The team entity to which points will be added
       @param kills: The number of kills to add
       @param points: The number of points to add
    */
    func AddPointsToTeam(team entity<Team>, kills int, booyah int) {
        if (ContainKey(teamBooyah, team) && ContainKey(teamKills, team) && ContainKey(teamTotalPoints, team)) {
            teamBooyah[team] = teamBooyah[team] + booyah // Increment the team's booyah points
            teamKills[team] = teamKills[team] + kills // Increment the team's kills
            teamTotalPoints[team] = teamTotalPoints[team] + booyah + kills // Increment the team's total points
            LogInfo("<TeamData.fcg>: Added " + teamTotalPoints[team] + " points to team: " + team<Entity>.Name) // Debug Info
        } else {
            LogError("<TeamData.fcg>: Team not found: " + team<Entity>.Name) // Error Info
        }
    }

    /* Add winning times to a specific team.
       @param team: The team entity to which winning times will be added
    */
    func AddWinningTimesToTeam(team entity<Team>) {
        if (ContainKey(teamWinningTimes, team)) {
            teamWinningTimes[team] = teamWinningTimes[team] + 1 // Increment the team's winning times
        } else {
            LogError("<TeamData.fcg>: Team not found: " + team<Entity>.Name) // Error Info
        }
    }

    /* Get the current winning times for a specific team.
       @param team: The team entity to get the winning times from.
       @return: The current winning times for the specified team.
    */
    func GetTeamWinningTimes(team entity<Team>) int {
        if (ContainKey(teamWinningTimes, team)) {
            return teamWinningTimes[team] // Return the team's winning times
        } else {
            LogError("<TeamData.fcg>: Team not found: " + team<Entity>.Name) // Error Info
            return 0 // Return zero if the team is not found
        }
    }

    /* Get the current points for all teams.
       This function returns the map of team points.
       @return: A map of entity<Team> to int representing team points
    */
    func GetTeamBooyahs() Map<entity<Team>, int> {
        return teamBooyah // Return the map of team booyah
    }

    /* Get the current booyah for a specific team.
       @param team: The team entity to get the booyah from.
       @return: The current booyah for the specified team.
    */
    func GetTeamBooyah(team entity<Team>) int {
        if (ContainKey(teamBooyah, team)) {
            return teamBooyah[team] // Return the booyah points for the specified team
        } else {
            LogError("<TeamData.fcg>: Team not found: " + team<Entity>.Name) // Error Info
            return -1 // Return -1 if the team is not found
        }
    }

    /* Get the current kills for all teams.
       This function returns the map of team kills.
       @return: A map of entity<Team> to int representing team kills
    */
    func GetTeamKills() Map<entity<Team>, int> {
        return teamKills // Return the map of team kills
    }

    /* Get the current total points for all teams.
       This function returns the map of team total points.
       @return: A map of entity<Team> to int representing team total points
    */
    func GetTeamTotalPoints() Map<entity<Team>, int> {
        return teamTotalPoints // Return the map of team total points
    }

    /* Get the current point of one team
        @param team: The team entity to get the point.
        @return: The current booyah points of the specified team.
    */
    func GetTeamTotalPoint(team entity<Team>) int {
        if (ContainKey(teamTotalPoints, team)) {
            return teamTotalPoints[team] // Return the total points for the specified team
        } else {
            LogError("<TeamData.fcg>: Team not found: " + team<Entity>.Name) // Error Info
            return 0 // Return zero if the team is not found
        }
        // LogInfo("<TeamData.fcg>: Current points " + teamPoints) // Debug Info
    }

    /* Get the team list sorted by points
       @return: A list of teams sorted by their points in descending order
    */
    func GetSortedTeamList() List<entity<Team>>{
        var sortedTeams List<entity<Team>> = List<entity<Team>>{}
        var teamCopyDict Map<entity<Team>, int> = Map<entity<Team>, int>{} 
        var currentAliveTeams List<entity<Team>> = globalEntity<GlobalGameManager>.GetCurrentActiveTeams()
        for team, point in teamTotalPoints {
            if List.Contain(currentAliveTeams, team) {
                teamCopyDict[team] = point
            }
        }
        while Map.Length(teamCopyDict) > 0 {
            var currentMaxTeam = GetAllKeys(teamCopyDict)[0]
            for index, team in GetAllKeys(teamCopyDict) {
                if teamCopyDict[team as entity<Team>] > teamCopyDict[currentMaxTeam as entity<Team>] {
                    currentMaxTeam = team
                } else if teamCopyDict[team as entity<Team>] == teamCopyDict[currentMaxTeam as entity<Team>] {
                    // If points are equal, prefer the team with more kill points
                    // var currentMaxTeamKills int = 0
                    // var teamKills int = 0
                    // for index, player in currentMaxTeam as entity<Team><Team>.AllTeammates {
                    //     currentMaxTeamKills = currentMaxTeamKills + globalEntity<PlayerData>.GetPlayerData(player)[0] // Sum kills of all teammates
                    // }
                    // for index, player in team as entity<Team><Team>.AllTeammates {
                    //     teamKills = teamKills + globalEntity<PlayerData>.GetPlayerData(player)[0] // Sum kills of all teammates
                    // }
                    // if teamKills > currentMaxTeamKills {
                    //     currentMaxTeam = team
                    // }
                    if teamBooyah[team as entity<Team>] > teamBooyah[currentMaxTeam as entity<Team>] {
                        currentMaxTeam = team
                    } else if teamBooyah[team as entity<Team>] == teamBooyah[currentMaxTeam as entity<Team>] {
                        if teamKills[team as entity<Team>] > teamKills[currentMaxTeam as entity<Team>] {
                            currentMaxTeam = team
                        }
                    } 
                }
            }
            Append(sortedTeams, currentMaxTeam)
            Map.Remove(teamCopyDict, currentMaxTeam)
        }
        return sortedTeams
    }

    /*Get players grouped by their teams for full scoreboard
    @return: A list of lists, where each inner list contains players from the same team
    */
    func GetSortedPlayersGroup() List<List<entity<Player>>> {
        var sortedTeams List<entity<Team>> = GetSortedTeamList()
        var sortedPlayersGroup List<List<entity<Player>>> = List<List<entity<Player>>>{}
        for index, team in sortedTeams {
            var playersInTeam List<entity<Player>> = GetSortedPlayersInTeam(team)
            Append(sortedPlayersGroup, playersInTeam)
        }
        return sortedPlayersGroup
    }

    /*
    Get the sorted players in a specific team.
    @param team: The team entity to get the sorted players from.
    @return: A list of players sorted by their scores.
    */
    func GetSortedPlayersInTeam(team entity<Team>) List<entity<Player>> {
        var playersInTeam List<entity<Player>> = List<entity<Player>>{}
        for index, player in team<Team>.AllTeammates {
            Append(playersInTeam, player)
        }
        var sortedPlayers List<entity<Player>> = List<entity<Player>>{}
        while List.Length(playersInTeam) > 0 {
            var highestPlayer = playersInTeam[0]
            for index, player in playersInTeam {
                if (globalEntity<PlayerData>.GetPlayerData(player)[0] > globalEntity<PlayerData>.GetPlayerData(highestPlayer)[0]) {
                    highestPlayer = player
                } else if (globalEntity<PlayerData>.GetPlayerData(player)[0] == globalEntity<PlayerData>.GetPlayerData(highestPlayer)[0]) {
                    if (globalEntity<PlayerData>.GetPlayerData(player)[2] > globalEntity<PlayerData>.GetPlayerData(highestPlayer)[2]) {
                        highestPlayer = player
                    }
                }
            }
            List.Remove(playersInTeam, highestPlayer)
            Append(sortedPlayers, highestPlayer)
        }
        return sortedPlayers
    }

    /*
    Get the sorted scores for all teams.
    @return: A list of integers representing the sorted scores of all teams, in sorted order, for using together with GetSortedPlayersGroup()
    */
    func GetSortedScores() List<int> {
        var sortedTeams List<entity<Team>> = GetSortedTeamList()
        var sortedScores List<int> = List<int>{}
        for index, team in sortedTeams {
            Append(sortedScores, teamTotalPoints[team])
        }
        // LogError(sortedScores)
        return sortedScores
    }
}

// DEPRECATED FUNCTIONS
    /* Set the kills for a specific team.
       @param team: The team entity for which to set the kills.
       @param kills: The number of kills to set.
    */
    // func SetTeamKills(team entity<Team>, kills int) {
    //     if(!ContainKey(teamKills, team)) {
    //         teamKills[team] = 0 // Initialize kills for the team if not already set
    //     }
    //     if(kills != 0){
    //         teamKills[team] = kills
    //     }
    // }

    /* Get the kills for a specific team.
       @param team: The team entity for which to get the kills.
       @return: The number of kills for the specified team.
    */
    // func GetTeamKills(team entity<Team>) int {
    //     if(ContainKey(teamKills, team)) {
    //         return teamKills[team]
    //     }
    //     return -1
    // }