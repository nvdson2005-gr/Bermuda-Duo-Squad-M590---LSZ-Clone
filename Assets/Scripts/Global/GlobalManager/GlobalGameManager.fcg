/* GlobalGameManager.fcg
    Description: This script manages global game settings and events.
    It is responsible for initializing global game data, initializing player state and handling game-wide events.
    This is the replacement for Global.eca and Global.fcg
*/
import "../GlobalData/TeamsAlive.fcg" as TeamsAlive
import "StdLibrary.fcc" as StdLib
import "EditorGenLib.fcc" as EditorLib
import "../GlobalData/TeamPoints.fcg" as TeamPoints
import "../GlobalData/SpawnPoints.fcg" as SpawnPoints
import "Player.fcc" as Player
import "Hostility.fcc" as Hostility
import "Workflow.fcc" as Workflow
import "Items.fcc" as Items
import "../../Libraries/CustomEvent.fcc" as CustomEvent
import "../GlobalData/PlayersTimerUI.fcg" as PlayersTimerUI
import "./GlobalUIManager.fcg" as GlobalUIManager
import "../GlobalData/TeamData.fcg" as TeamData
import "../../Player/PlayerController.fcg" as PlayerController
import "../GlobalData/TargetAndCombatTimer.fcg" as TargetAndCombatTimer
import "../GlobalManager/GlobalSoundManager.fcg" as GlobalSoundManager
import "../GlobalData/PlayerData.fcg" as PlayerData
import "../GlobalData/GlobalSafeZones.fcg" as GlobalSafeZones
import "../GlobalManager/GlobalPreparationPhaseManager.fcg" as GlobalPreparationPhaseManager
import "Hud.fcc" as Hud
import "Combat.fcc" as Combat
import "SafeZone.fcc" as SafeZone
import "MiniMap.fcc" as MiniMap
import "../GlobalData/GlobalRandomEvent.fcg" as GlobalRandomEvent
import "../GlobalData/GlobalConfig.fcg" as GlobalConfig
import "../GlobalManager/GlobalCombatManager.fcg" as GlobalCombatManager
import "../../Team/TeamCurrentRoundData.fcg" as TeamCurrentRoundData
import "../GlobalData/CombatRoundCounter.fcg" as CombatRoundCounter
import "List.fcc" as List
import "LevelObject.fcc" as LevelObject
import "../../Team/Team.fcg" as TeamFCG
import "Convert.fcc" as Convert
import "../../Player/PlayerSoundManager.fcg" as PlayerSoundManager
import "../../Player/PlayerUI.fcg" as PlayerUI
graph GlobalGameManager {
    // winPoints int = 3 // Number of points required to win the game
    availableStages int = 11 // Number of available stages in the game, goes together with the number of safe zones and spawn point groups in GlobalSafeZones.cfg and SpawnPoints.cfg
    prepPhaseDuration int = 15 // Use this to customize the buying phase duration
    phaseDuration Map<EPhase, float> = Map<EPhase, float>{}
    isMatchEnded bool = false
    isRoundEnded bool = false
    /* 
    When the game starts:
    - If a player goes into the game to soon, a gravity delay is added to wait until the terrain is loaded.
    */
    event OnGameStart() {
        // LogInfo("<GlobalGameManager.fcg>: Game has started") // Debug Info
    }

    /*
    When a player joins the game:
    - Set the invincibility status for the player to true
    - Add a delay before the player can move
    - Added items to the player
    (Maybe move this to when round starts, as these items should be renew every round)
    */
    event OnPlayerJoin(player entity<Player>) {
        // Register necessary UIs
        // start globalEntity<GlobalUIManager>.CreateGlobalOpeningHUD(player)
        globalEntity<PlayerData>.RegisterPlayer(player) // Register the player for player data tracking
        globalEntity<GlobalUIManager>.RegisterMiniScoreBoard(player) // Register the player's mini scoreboard UI
        globalEntity<GlobalUIManager>.RegisterFullScoreBoard(player) // Register the player's full scoreboard UI
        globalEntity<TargetAndCombatTimer>.RegisterGameInfo(player) // Register the player's combat timer
        globalEntity<GlobalUIManager>.RegisterVoteUI(player) // Register the player's vote UI
        globalEntity<GlobalUIManager>.RegisterEventUI(player) // Register the player's event UI
        // Init necessary data
        SetDropStatus(player, false) // Keep the player's weapons when dead

        // Set invincible when player is dead, and teleport to the start zone
        if globalEntity<Global>.CurrentRoundIndex != 0 {
            SetInvincibility(player, 30);
            if GlobalConfig.MAP_CHOSEN == EResScene.OLD_PEAK {
                TransportToGameStartZone(player, EResSceneOLD_PEAK.GameStartSpawnPoint<Transform>.Position)
            }
        }
        SetUpMiniMap(player)


        // Use a custom minimap to increase the scale of the map
        // var fullMap = EResSprite.FullMap as IconType
        // CreateMiniMapIcon(out var miniMapIcon, player, fullMap)
        // miniMapIcon<MiniMapIcon>.Depth = 0
        // miniMapIcon<MiniMapIcon>.Offset = Vector3{523, 50, 110}

        // var miniMap entity<MiniMap> = GetMiniMap(player)
        // miniMap<MiniMap>.Center = Vector3{523, 50, 110}
        // miniMap<MiniMap>.MapSize = 942 
    }

    // When a new phase starts, update the UI and game state accordingly
    event OnPhaseStart(phase entity<Phase>) {
        if (phase<Phase>.Index == EPhase.Preparation) {
            start PreparationPhaseUIHandler(phase<Phase>.Duration) // Start the preparation phase UI handler
        }
        if phase<Phase>.Index == EPhase.End {
            var winningTeams = GetAllWinningTeams()
            var teamSortedList = globalEntity<TeamData>.GetSortedTeamList()
            for index, player in GetAllPlayers(){
                var team entity<Team> = player<Player>.HostTeam
                if List.Contain(winningTeams, team) { 
                    globalEntity<GlobalUIManager>.CreateEndGameHUD(player, team, 1, teamSortedList)
                } else {
                    globalEntity<GlobalUIManager>.CreateEndGameHUD(player, team, 2, teamSortedList)
                }
            }
        }
        // if phase<Phase>.Index == EPhase.Vote{
        //     // LogError("winningTeams: " + GetAllWinningTeams())
        // }
        if phase<Phase>.Index == EPhase.EndCombat {
            start SetAllPlayerFullScoreBoard()
        }
    }

    event OnPhaseEnd(phase entity<Phase>) {
        if phase<Phase>.Index == EPhase.End {
            isRoundEnded = false
        }
        if phase<Phase>.Index == EPhase.EndCombat {
            isRoundEnded = false
        }
    }

    async func SetAllPlayerFullScoreBoard(){
        WaitForMillisecond(1000)
        for index, player in GetAllPlayers() {
            globalEntity<GlobalUIManager>.SetVisibilityFullScoreBoard(player, true); // Update the full scoreboard UI
        }
    }

    /* When a player quits the game midway:
    - Eliminate the player immediately
    - Unregister from all UI elements to avoid unwanted bugs
    */
    event OnPlayerQuit(player entity<Player>) {
        // LogError("<GlobalGameManager.fcg>: Player " + player<Player>.NickName + " has quit the game") // Debug Info
        globalEntity<GlobalUIManager>.UnregisterAllUIs(player)
        globalEntity<PlayerData>.UnregisterPlayer(player) // Unregister the player from player data tracking
        player<PlayerUI>.UnregisterAllUIs()
        EliminateAtNextFrame(player)
        globalEntity<GlobalUIManager>.UpdateMiniScoreboard() // Update the mini scoreboard UI after a player is eliminated to update current alives
        var activeTeams = GetCurrentActiveTeams()
        if isMatchEnded == false {
            if List.Length(activeTeams) <= 1 {
                MatchEndHandler(activeTeams[0])
            } else {
                if isRoundEnded == false {
                    globalEntity<GlobalCombatManager>.CheckEndCombatCondition()
                }
            }
        }
    }

    /*
    This function is called when the preparation phase starts for a player.
    It sets up the necessary UI elements and registers the player for the tutorial.
    @param player The player entity that is starting the preparation phase.
    */
    async func PreparationPhaseUIHandler(phaseDuration int) {
        WaitForMillisecond(phaseDuration - 5000)
        globalEntity<PlayersTimerUI>.SetTimerVisibility(false)
        for index, player in GetAllPlayers() {
            start globalEntity<GlobalUIManager>.Enable5sCountdownHUD(player)
        }
    }

    /* When a team is added:
    - Log info.
    - Register the team in TeamPoints
    */
    event OnTeamAdd(team entity<Team>) {
        // Register the team in TeamData
        if globalEntity<TeamData>.RegisterTeamPoint(team) == true {
        }
        // Register the team in TeamsAlive
        if globalEntity<TeamsAlive>.RegisterTeam(team) == true {
        }
    }

    // Custom event sent from GlobalCombatManager, together with the winning team
    /*
    This event is triggered when a round ends.
    - Log info
    - Add points to winning team
    - Check if that team wins or not
    */
    event CombatEnd(winningTeam entity<Team>) {
        isRoundEnded = true
        if (winningTeam == nil) {
            // LogError("There is no team winning this round")
            EndCurrentPhase()
        }
        // LogInfo("<GlobalGameManager.fcg>: Round ended. Winning team: " + winningTeam) // Debug Info
        // globalEntity<GlobalUIManager>.CreatePlusAnimation(winningTeam)
        globalEntity<GlobalUIManager>.UpdateMiniScoreboard(); // Update the scoreboard for the winning team
        for index, teammate in winningTeam<Team>.AllTeammates {
            if teammate<Player>.HP > 0 {
                SetInvincibility(teammate, 60)
            }
        }
        var teamRanking = globalEntity<GlobalCombatManager>.teamRanking
        globalEntity<TeamCurrentRoundData>.IncreaseBooyah()
        WaitForNextFrame()
        globalEntity<TeamData>.AddPointsToTeam(winningTeam, winningTeam<TeamCurrentRoundData>.GetKillThisRound(), List.Length(teamRanking) + 1)
        globalEntity<TeamData>.AddWinningTimesToTeam(winningTeam)
        for index, team in teamRanking {
            team<TeamFCG>.SetLastRoundPoint(globalEntity<TeamData>.GetTeamTotalPoint(team))
            globalEntity<TeamData>.AddPointsToTeam(team, team<TeamCurrentRoundData>.GetKillThisRound(), index + 1)
        }
        ClearResidualLevelObjects()
        globalEntity<GlobalRandomEvent>.ResetChosenEvent()
        for index, player in GetAllPlayers() {
            ClearBackpack(player)
            player<PlayerSoundManager>.StopAllLoopingSounds()
        }
        if CheckWinningCondition() {
            isMatchEnded = true
            wait globalEntity<GlobalUIManager>.CreateEndRoundHUD(winningTeam); // Create the end round HUD for all players
            start globalEntity<GlobalUIManager>.UpdateFullScoreBoardWinTeam(winningTeam);
            SwitchPhase(EPhase.EndCombat) // Switch to the end combat phase to allow players to see the full scoreboard
            WaitForMillisecond(7000)
            var allWinningTeams = GetAllWinningTeams()
            // LogInfo("<GlobalGameManager.fcg>: Team(s) " + allWinningTeams + " have won the game!") // Debug Info
            for index, player in GetAllPlayers() {
                player<PlayerSoundManager>.StopAllLoopingSounds()
                globalEntity<GlobalUIManager>.UnregisterAllUIs(player) // Unregister all UIs for the player
                start globalEntity<GlobalUIManager>.CreateLastRoundHUD(allWinningTeams, player) // Create the last round HUD for all players
                globalEntity<GlobalSoundManager>.PlayEndMatchSound(player)            
            }
            WaitForMillisecond(3000)
            SwitchPhase(EPhase.End)
        } else {
            wait globalEntity<GlobalUIManager>.CreateEndRoundHUD(winningTeam); // Create the end round HUD for all players
            start globalEntity<GlobalUIManager>.UpdateFullScoreBoardWinTeam(winningTeam);
            // EndCurrentPhase()
            SwitchPhase(EPhase.EndCombat) // Switch to the end combat phase to allow players to see the full scoreboard
        }
    }

    // Custom event, used to handle the case where no team wins
    event NoTeamWinException() {
        // LogError("<GlobalGameManager.fcg>: No team won this round, skipping to the next round") // Debug Info
        globalEntity<GlobalRandomEvent>.ResetChosenEvent()
        if CheckWinningCondition() {
            for index, player in GetAllPlayers() {
                player<PlayerSoundManager>.StopAllLoopingSounds()
                globalEntity<GlobalUIManager>.UnregisterAllUIs(player) // Unregister all UIs for the player
                start globalEntity<GlobalUIManager>.CreateLastRoundHUD(GetAllTeams(), player) // Create the last round HUD for all players
                globalEntity<GlobalSoundManager>.PlayEndMatchSound(player)            
            }
            WaitForMillisecond(2000)
            SwitchPhase(EPhase.End)
        } else {
            var teamRanking = globalEntity<GlobalCombatManager>.teamRanking
            globalEntity<TeamCurrentRoundData>.IncreaseBooyah()
            WaitForNextFrame()
            for index, team in teamRanking {
                team<TeamFCG>.SetLastRoundPoint(globalEntity<TeamData>.GetTeamTotalPoint(team))
                globalEntity<TeamData>.AddPointsToTeam(team, team<TeamCurrentRoundData>.GetKillThisRound(), index + 1)
            }
            start globalEntity<GlobalUIManager>.UpdateFullScoreBoardWinTeam(nil);
            SwitchPhase(EPhase.EndCombat)
        }
    }

    // =========== UTILS FUNCTIONS ================
    // TEAM FUNCTIONS
    func GetAllWinningTeams() List<entity<Team>> {
        var winningTeams List<entity<Team>> = globalEntity<TeamData>.GetSortedTeamList()
        var returnList List<entity<Team>> = List<entity<Team>>{}
        if List.Length(winningTeams) <= 1 {
            return winningTeams
        }
        Append(returnList, winningTeams[0])
        for index, team in winningTeams {
            if globalEntity<TeamData>.GetTeamTotalPoint(team) < globalEntity<TeamData>.GetTeamTotalPoint(winningTeams[0]) || team == winningTeams[0] {
                continue
            }
            Append(returnList, team)
        }
        return returnList
    }
    /* 
    Check if a team satisfies the winning condition
    @param team: The team entity to check
    @return: Bool value indicating whether the team has won
    */
    func CheckWinningCondition() bool {
        if globalEntity<CombatRoundCounter>.GetCount() >= GlobalConfig.MAX_ROUND {
            return true
        }
        return false
    }

    /*
    Teleports a player to the game start zone.
    @param player: The player entity to teleport
    @param startZonePosition: The position to teleport the player to
    */
    func TransportToGameStartZone(player entity<Player>, startZonePosition Vector3) {
        Teleport(player, startZonePosition, Vector3{0, 0, 0})
    }

    /*
    Get the number of active teams (this is used as an alternative to GetAllTeams(), since GetAllTeams() returns all Team entities (including quitted teams), not just the active ones)
    @return: The number of active teams
    */
    func GetCurrentActiveTeams() List<entity<Team>> {
        var teamList = List<entity<Team>>{}
        for key, player in GetAllPlayers() {
            var team = player<Player>.HostTeam
            if !List.Contain(teamList, team) {
                Append(teamList, team)
            }
        }
        return teamList
    }

    async func SetUpMiniMap(player entity<Player>) {
        var fullMap = EResSprite.MINIMAP as IconType
        CreateMiniMapIcon(out var miniMap, player, fullMap)
        // miniMap<MiniMapIcon>.Depth = 0
        miniMap<MiniMapIcon>.Offset = Vector3{0, 0, 0}
        miniMap<MiniMapIcon>.Scale = 1.65 
        var minimap = GetMiniMap(player)
        minimap<MiniMap>.MapSize = 150
        minimap<MiniMap>.EnableDepthMap = false
        // for key, value in FilterLevelObjects(LevelObjectType.SpawnPos) {
        //     CreateMiniMapPixel(out var miniMapPixel, player, value)
        // }
        // CreateMiniMapPixel(out var house1, player, EResSceneACADEMY.HOUSE1 as entity<Entity>)
        // CreateMiniMapPixel(out var house2, player, EResSceneACADEMY.HOUSE2 as entity<Entity>)
        // CreateMiniMapPixel(out var bridge, player, EResSceneACADEMY.BRIDGE as entity<Entity>)
        // for index, value in GetChildren(EResSceneACADEMY.OTHER_LEVEL_OBJECTS as entity<Entity>) {
        //     CreateMiniMapPixel(out var otherLevelObject, player, value)
        // }
            // for index, value in GetChildren(EResSceneOLD_PEAK.Building as entity<Entity>) {
            //     CreateMiniMapPixel(out var building, player, value)
            // }
        CreateMiniMapPixel(out var builtInPixel, player, EResSceneOLD_PEAK.Building as entity<Entity>)
        CreateMiniMapPixel(out var ground, player, EResSceneOLD_PEAK.Ground as entity<Entity>)
        for index, value in GetChildren(EResSceneOLD_PEAK.OTHER_LEVEL_OBJECTS as entity<Entity>) {
            CreateMiniMapPixel(out var otherLevelObject, player, value)
        }
    }

        /*
    This function is called when a match ends.
    @param winningTeam: The winning team entity
    */
    async func MatchEndHandler(winningTeam entity<Team>){
        isMatchEnded = true
        // LogInfo("<GlobalGameManager.fcg>: Team " + winningTeam<Entity> + " has won the game!") // Debug Info
        for index, player in GetAllPlayers() {
            globalEntity<GlobalUIManager>.UnregisterAllUIs(player) // Unregister all UIs for the player
            start globalEntity<GlobalUIManager>.CreateLastRoundHUD(List<entity<Team>>{winningTeam}, player) // Create the last round HUD for all players
            globalEntity<GlobalSoundManager>.PlayEndMatchSound(player)            
        }
        WaitForMillisecond(5000)
        SwitchPhase(EPhase.End)
    }
}
